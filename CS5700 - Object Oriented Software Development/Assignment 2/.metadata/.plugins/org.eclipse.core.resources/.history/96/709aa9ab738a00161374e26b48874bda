package com.usu.simulatorCommunication.messages;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Map.Entry;
import java.util.concurrent.ThreadPoolExecutor;

import com.usu.stocks.Portfolio;
import com.usu.stocks.Stock;

public class SimulatorCommunicator {
	
	DatagramSocket clientSocket;
	Portfolio portfolios;
	
	public void receiveUDPPacket() throws Exception {
		clientSocket = new DatagramSocket(12099, InetAddress.getByName("172.31.29.240"));
		byte[] receiveData = new byte[1024];
		DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
		clientSocket.receive(receivePacket);
		System.out.println("Connection Status: " + clientSocket.isConnected());
		//ThreadPoolExecutor tickerPool = new ThreadPoolExecutor(50, 1000);
	}
	
	public void stopUDPPacket() throws SocketException, Exception {
		if(clientSocket != null) {
			clientSocket.close();
			clientSocket = null;
		}
	}
	
	private void Monitoring(object state)
    {
        if (portfolios == null)
        	return;
        
        StreamStocksMessage startMessage = new StreamStocksMessage();
        for(Entry<String, Stock> stockPair : portfolios.entrySet())
           startMessage.Add(stockPair.getKey());
        Send(startMessage);

        while (_isMonitoring)
        {
            // Try to receive a TickerMessage and pass it onto the Portfolio for processing.  It will
            // wait 1000 ms before giving up on the receive attempt.  In that case, the message will
            // be null and the Portfolio.Update method will do nothing.
            try
            {
                var message = Receive(1000);
                Portfolio.Update(message);
            }
            catch (Exception)
            {                    
                // TODO: Handle the error.  For example, you may want to Stop the communicator and log the error
            }
        }
    }
}