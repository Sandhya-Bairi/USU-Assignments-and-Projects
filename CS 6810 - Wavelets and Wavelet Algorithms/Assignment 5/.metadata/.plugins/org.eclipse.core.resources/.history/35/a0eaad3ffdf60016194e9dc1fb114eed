package Problem1;

public class CDF24 {
	static final double SQRT_OF_3 = Math.sqrt(3);
	protected final static double denom = 4 * Math.sqrt(2);

	// forward transform smoothing coefficients
	protected final static double h0 = (1 + SQRT_OF_3)/denom;
	protected final static double h1 = (3 + SQRT_OF_3)/denom; 
	protected final static double h2 = (3 - SQRT_OF_3)/denom; 
	protected final static double h3 = (1 - SQRT_OF_3)/denom;

	// forward transform wavelet coefficients
	protected final static double g0 =  h3;
	protected final static double g1 = -h2;
	protected final static double g2 =  h1;
	protected final static double g3 = -h0;

	// Inverse transform coefficients for smoothed values
	protected final static double Ih0 = h2;
	protected final static double Ih1 = g2;
	protected final static double Ih2 = h0;
	protected final static double Ih3 = g0;

	// Inverse transform for wavelet values
	protected final static double Ig0 = h3;
	protected final static double Ig1 = g3;
	protected final static double Ig2 = h1;
	protected final static double Ig3 = g1;


	public static void ordDWTForNumIters(double[] signal, int num_iters) {
		final int length = signal.length;
		if (length < 4 || !Utils.isPowerOf2(length)) {
			System.out.println("CDF can't be done: Signal length is either less than 4 or not power of 2");
			return;
		}

		int currScale = 0;
		int i, j, mid;
		double tmp[] = new double[length];
		while (length >= 4)  {
			mid = length >> 1; // n / 2;
			tmp = new double[length]; // temporary array that saves the scalers and wavelets
			for(i = 0, j = 0; j < length-3; i += 1, j += 2) {
				tmp[i]     = h0*signal[j] + h1*signal[j+1] + h2*signal[j+2] + h3*signal[j+3];
				tmp[mid+i] = g0*signal[j] + g1*signal[j+1] + g2*signal[j+2] + g3*signal[j+3];
			}

			tmp[i] = h0*signal[length-2] + h1*signal[length-1] + h2*signal[0] + h3*signal[1];
			tmp[mid+i] = g0*signal[length-2] + g1*signal[length-1] + g2*signal[0] + g3*signal[1];

			System.arraycopy(tmp, 0, signal, 0, tmp.length);
			tmp = null;
			length >>= 1;

			currScale     += 1;
			if ( currScale >= num_iters ) return;
		}
	}

	public static void ordInvDWTForNumIters(double[] signal, int num_iters) {

	}
}