package Problem1;

public class CDF24 {
	static final double SQRT_OF_3 = Math.sqrt(3);
	protected final double denom = 4 * Math.sqrt(2);

	// forward transform smoothing coefficients
	protected final double h0 = (1 + SQRT_OF_3)/denom;
	protected final double h1 = (3 + SQRT_OF_3)/denom; 
	protected final double h2 = (3 - SQRT_OF_3)/denom; 
	protected final double h3 = (1 - SQRT_OF_3)/denom;

	// forward transform wavelet coefficients
	protected final double g0 =  h3;
	protected final double g1 = -h2;
	protected final double g2 =  h1;
	protected final double g3 = -h0;

	// Inverse transform coefficients for smoothed values
	protected final double Ih0 = h2;
	protected final double Ih1 = g2;
	protected final double Ih2 = h0;
	protected final double Ih3 = g0;

	// Inverse transform for wavelet values
	protected final double Ig0 = h3;
	protected final double Ig1 = g3;
	protected final double Ig2 = h1;
	protected final double Ig3 = g1;


	public static void ordDWTForNumIters(double[] signal, int num_iters) {
		final int N = signal.length;
		if ( N < 4 || !Utils.isPowerOf2(N) ) {
			System.out.println("CDF can't be done: Signal length is either less than 4 or not power of 2");
			return;
		}
		int i, j, mid;
		double[] D4 = null;

		if (dbg_flag) { 
			System.out.print("=>INPUT: ");
			Utils.displaySample(signal);
		}

		int numScalesToDo = Utils.wholeLog2(N)-1; 
		int currScale  = 0;
		int signal_length = N;
		while ( signal_length >= 4 )  {

			mid = signal_length >> 1;
			if ( dbg_flag ) System.out.println("MID           = " + mid);
			if ( dbg_flag ) System.out.println("signal_length = " + signal_length);
			D4 = new double[signal_length];
			for(i = 0, j = 0; j < signal_length-3; i += 1, j += 2) {
				if ( dbg_flag ) {
					final String cursig = "s^{" + (currScale+1) + "}_{" + (numScalesToDo-1) + "}";
					final String prvsig = "s^{" + currScale + "}_{" + numScalesToDo + "}";
					System.out.println("FWD SCL:  " + cursig + "[" + i + "]=" + "H0*" + prvsig + "[" + j + "]+H1*" + prvsig + "[" + (j+1) + "]+" +
							"H2*" + prvsig + "[" + (j+2) + "]+" + "H3*" + prvsig + "[" + (j+3) + "]; " );
					System.out.println("FWD WVL:  " + cursig + "[" + (mid+i) + "]=" + "G0*" + prvsig + "[" + j + "]+" + "G1*" + prvsig + "[" + (j+1) + "]+" +
							"G2*" + prvsig + "[" + (j+2) + "]+" + "G3*" + prvsig + "[" + (j+3) + "]" );
				}

				D4[i]     = h0*signal[j] + h1*signal[j+1] + h2*signal[j+2] + h3*signal[j+3];
				D4[mid+i] = g0*signal[j] + g1*signal[j+1] + g2*signal[j+2] + g3*signal[j+3];
			}

			D4[i]     = h0*signal[signal_length-2] + h1*signal[signal_length-1] + h2*signal[0] + h3*signal[1];
			D4[mid+i] = g0*signal[signal_length-2] + g1*signal[signal_length-1] + g2*signal[0] + g3*signal[1];

			if ( dbg_flag ) {
				final String cursig = "s^{" + currScale + "}_{" + numScalesToDo + "}";
				final String prvsig = "s^{" + (currScale-1) + "}_{" + (numScalesToDo+1) + "}";
				System.out.println("FWD SCL:  " + cursig + "[" + i + "]=" + "H0*" + prvsig + "[" + (signal_length-2) + "]+H1*" + prvsig + "[" + (signal_length-1) + "]+" +
						"H2*" + prvsig + "[" + 0 + "]+" + "H3*" + prvsig + "[" + 1 + "]; " );
				System.out.println("FWD WVL:  " + cursig + "[" + (mid+i) + "]=" + "G0*" + prvsig + "[" + (signal_length-2) + "]+" + "G1*" + prvsig + "[" + (signal_length-1) + "]+" +
						"G2*" + prvsig + "[" + 0 + "]+" + "G3*" + prvsig + "[" + 1 + "]" );
			}

			System.arraycopy(D4, 0, signal, 0, D4.length);
			D4 = null;
			signal_length >>= 1;

			currScale     += 1;
			numScalesToDo -= 1;
			if ( currScale >= num_iters ) return;
		}
	}
	public static void ordInvDWTForNumIters(double[] signal, int num_iters) {

	}
}