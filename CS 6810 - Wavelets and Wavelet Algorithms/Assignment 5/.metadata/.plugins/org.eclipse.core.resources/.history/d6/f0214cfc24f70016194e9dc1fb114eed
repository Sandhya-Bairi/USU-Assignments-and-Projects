package Problem1;

import java.util.Arrays;

public class CDF24 {
	static final double SQRT_OF_3 = Math.sqrt(3);
	protected final static double denom = 4 * Math.sqrt(2);

	// forward transform smoothing coefficients
	protected final static double h0 = (1 + SQRT_OF_3)/denom;
	protected final static double h1 = (3 + SQRT_OF_3)/denom; 
	protected final static double h2 = (3 - SQRT_OF_3)/denom; 
	protected final static double h3 = (1 - SQRT_OF_3)/denom;

	// forward transform wavelet coefficients
	protected final static double g0 =  h3;
	protected final static double g1 = -h2;
	protected final static double g2 =  h1;
	protected final static double g3 = -h0;

	// Inverse transform coefficients for smoothed values
	protected final static double Ih0 = h2;
	protected final static double Ih1 = g2;
	protected final static double Ih2 = h0;
	protected final static double Ih3 = g0;

	// Inverse transform for wavelet values
	protected final static double Ig0 = h3;
	protected final static double Ig1 = g3;
	protected final static double Ig2 = h1;
	protected final static double Ig3 = g1;


	public static void ordDWTForNumIters(double[] signal, int num_iters) {
		int length = signal.length;
		if (length < 4 || !Utils.isPowerOf2(length)) {
			System.out.println("CDF can't be done: Signal length is either less than 4 or not power of 2");
			return;
		}

		int i, j, half;
		double tmp[] = new double[length];
		while(length >= 4)  {
			half = length/2;
			for(i = 0, j = 0; j < length-3; i += 1, j += 2) {
				tmp[i] = h0*signal[j] + h1*signal[j+1] + h2*signal[j+2] + h3*signal[j+3];
				tmp[half+i] = g0*signal[j] + g1*signal[j+1] + g2*signal[j+2] + g3*signal[j+3];
			}

			tmp[i] = h0*signal[length-2] + h1*signal[length-1] + h2*signal[0] + h3*signal[1];
			tmp[half+i] = g0*signal[length-2] + g1*signal[length-1] + g2*signal[0] + g3*signal[1];

			signal = Arrays.copyOf(tmp, tmp.length);
			tmp = null;
			length /= 2;
		}

		for(double d: signal)
			System.out.println(d);
		System.out.println();
	}

	public static void ordInvDWTForNumIters(double[] signal, int num_iters) {
		int N = signal.length;
		if (N < 4 || !Utils.isPowerOf2(N)) {
			System.out.println("CDF can't be done: Signal length is either less than 4 or not power of 2");
			return;
		}

		int numInvScalesToDo = Utils.wholeLog2(N)-1; 
		int currInvScale     = 0;
		int transform_length = 4;

		while ( transform_length <= N ) {
			int mid = transform_length >> 1;

		double[] inv_sig = new double[transform_length]; // restored values

		String cur_sig = null;
		String prv_sig = null;

		inv_sig[0] = IH0*signal_transform[mid-1] + IH1*signal_transform[transform_length-1] + IH2*signal_transform[0] + IH3*signal_transform[mid];
		inv_sig[1] = IG0*signal_transform[mid-1] + IG1*signal_transform[transform_length-1] + IG2*signal_transform[0] + IG3*signal_transform[mid];

		int i = 0, j = 2;

		while(i < mid-1) {               
			inv_sig[j] = IH0*signal_transform[i] + IH1*signal_transform[mid+i] + IH2*signal_transform[i+1] + IH3*signal_transform[mid+i+1];
			inv_sig[j+1] = IG0*signal_transform[i] + IG1*signal_transform[mid+i] + IG2*signal_transform[i+1] + IG3*signal_transform[mid+i+1];
			i += 1; j += 2;
		}

		currInvScale     += 1;
		numInvScalesToDo -= 1;

		System.arraycopy(inv_sig, 0, signal_transform, 0, inv_sig.length);
		transform_length *= 2;
		}
	}
}